%GENPROGRESSPOLYGONS
% This script generate polygons representing the harvest progress for all
% fields involved, based on the outputs of the naiveTrain program.
%
% TODO: try potential for in-field classification.
%
% Yaguang Zhang, Purdue, 10/30/2020

%% Set Matlab Path.

% Clear command window. Close all plot & web map display windows.
clc; clearvars -except strYearToProcess; close all;

disp('===================');
disp('genProgressPolygons');
disp('===================');

% Changed folder to "ScriptsAndFunctions" first.
cd(fullfile(fileparts(which(mfilename)), '..'));
% Set path.
setMatlabPath;

%% User Specified Parameters

if ~exist('strYearToProcess', 'var')
    strYearToProcess = '2019';
end
fileFolder = fullfile('..', '..', '..', ...
    ['Harvest_Ballet_', strYearToProcess]);

fileFolderSet = fullfile(pwd, fileFolder);
FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS = fullfile(fileFolderSet, ...
    '_AUTOGEN_IMPORTANT', 'ProgressPolygons');

% Set this to true to use road polygons extracted from truck tracks to
% refine the in-field labels. Note: this will be computationally expensive.
FLAG_GENERATE_ROAD_POLYSHAPE = true;
FLAG_REFINE_LOCS_BY_TRUCK_TRACKS = false;

% For refining in-field classification results.
MAX_COMBINE_SPEED_IN_FIELD = 5; % In m/s.
% Use 10 for SQUARE_SIDE_LENGTH = 200.
MIN_COMBINE_DENSITY_IN_FIELD = 10; % In #/(m^2).

MAX_TRUCK_SPEED_IN_FIELD = 10; % In m/s.
ROAD_ALPHA = 15; % In meters.

% For simplicity, we will expand the field polygon with GPS point vertices
% by half of the combine header width.
HEADER_WIDTH = 10; % In meters.

% We will also remove small pieces in the final field polygon.
MIN_FIELD_AREA = 5000; % In m^2.

% For visualizations. For simplicity, please make sure
% PLAYBACK_SPEED/VIDEO_FRAME_RATE is an integer. We use a prime number for
% the playback speed to avoid obvious patterns in time.
PLAYBACK_SPEED = 167; % 547;
VIDEO_FRAME_RATE = 1; % In FPS.
% The number of trailing GPS points to show for each type of vehicles.
NUM_OF_TRAILING_GPS_PTS = 120;
% We will gradually reduce the size and opacity of the points at past.
TRAILING_GPS_PTS_SIZE_RANGE = [1, 30];
% We will start the video demo only when the majority of at least this many
% future combine samples (including the current sample) have a non-zero
% speed.
MIN_NUM_OF_ACTIVE_SAMPS_C = 300;
% Note that there may be more than one combines in the samples to consider,
% so the ratio will be computed agaist time (unit: samples/second).
THRESHOLD_ACTIVE_SAMPS_MAJORITY = 0.75;
% If the progress goes up to this ratio, we will treat it as done.
MIN_RATIO_HARVEST_DONE = 0.999;
% After the harvest for one field is done, we will keep showing what
% happens for this time.
PADDING_TIME_AFTER_HARVEST_IN_S = 300;
% If all combines are inactive for this length of time or longer, we will
% remove that time segment from the video, and split the video into two,
% for before and after this inactive period, respectively.
MAX_ALLOWED_INACTIVE_TIME_LENGTH_IN_S = 300;
% We will add this long of video of the inactive segment for each clip from
% the split to indicate what has happened.
PADDING_TIME_FOR_INACTIVE_GAP_IN_S = 100;

% Colors of the fields.
faceColorField = 'g';
edgeColorField = faceColorField;
faceAlphaField = 0.1;
edgeAlphaField = 1;
faceColorProgPoly = 'r';
edgeColorProgPoly = faceColorProgPoly;
faceAlphaProgPoly = 0.1;
edgeAlphaProgPoly = 1;

colorC = 'y';
colorK = 'b';
colorT = 'k';
sizeHistGpsPt = 0.25;
alphaHistGpsPt = 0.25;

% The fontsize for the title in the harvest progress video demos.
titleFontSize = 10;

%% Data Set GPS Time Range
% Note that we have noticed a very small amount of GPS records with anomaly
% GPS time stamps, so here we will filter the data with expected GPS time
% range.
gpsTimeRangeInS = [ ...
    utc2gps(posixtime( ...
    datetime(['01-Jan-', strYearToProcess, ' 00:00:00']))), ...
    utc2gps(posixtime( ...
    datetime(['31-Dec-', strYearToProcess, ' 23:59:59'])))];

%% History Tracks to Load

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Loading GPS data...']);

FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY = fullfile(fileFolderSet, ...
    '_AUTOGEN_IMPORTANT');
FULLPATH_FILES_LOADED_HISTORY = fullfile(...
    FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY, ...
    'filesLoadedHistory.mat'...
    );

load(FULLPATH_FILES_LOADED_HISTORY, 'files', 'fileIndicesCombines');

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

%% History GPS Sample Density Info to Load

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
    '] Loading sample densities...']);

FULLPATH_DEV_IND_DENSITIES = fullfile(...
    FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY, 'naiveTrain', ...
    'DevIndSampleDensities_SQUARE_SIDE_LENGTH_200.mat'...
    );

load(FULLPATH_DEV_IND_DENSITIES);

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

%% In-Field Classification Results to Use

if ~exist(FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, 'dir')
    mkdir(FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS);
end

if FLAG_GENERATE_ROAD_POLYSHAPE
    
    filePathToLocs = fullfile(FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
        'locationInfo.mat');
    
    if ~exist(filePathToLocs, 'file')
        % We will refine the in-field location labels using truck tracks.
        disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
            '] Refining in-field location labels...']);
        
        load(fullfile(FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY, ...
            'filesLoadedLocations.mat'));
        
        % Find extra (relative to truck tracks) GPS points on road from
        % combine tracks. They will be used to help construct roads from
        % the truck tracks.
        boolsCombineFiles = strcmp({files.type}, 'Combine');
        extraLonLatOnRoad = [vertcat(files(boolsCombineFiles).lon), ...
            vertcat(files(boolsCombineFiles).lat)];
        extraSpeedC = vertcat(files(boolsCombineFiles).speed);
        extraDensityC = vertcat(devIndSampleDensities{boolsCombineFiles});
        % For location labels, -100 means "for sure on road".
        extraLonLatOnRoad( ...
            (extraSpeedC<=MAX_COMBINE_SPEED_IN_FIELD) ...
            |(extraDensityC>=MIN_COMBINE_DENSITY_IN_FIELD),:) = [];
        
        % Refine location labels based on truck tracks.
        filesTruck = files(strcmp({files.type}, 'Truck'));
        roadsPolyshapeLonLat = genRoadPolyshapeLonLat(filesTruck, ...
            MAX_TRUCK_SPEED_IN_FIELD, extraLonLatOnRoad, ROAD_ALPHA);
        if FLAG_REFINE_LOCS_BY_TRUCK_TRACKS
            locations = refineLocationsByRoadPolyshape( ...
                locations, files, roadsPolyshapeLonLat); %#ok<UNRCH>
        end
        
        disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
            '] Saving results...']);
        save(filePathToLocs, 'locations', 'roadsPolyshapeLonLat');
    else
        disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
            '] Loading refined in-field location labels...']);
        load(filePathToLocs);
    end
else
    disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Loading in-field location labels...']); %#ok<UNRCH>
    load(fullfile(FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY, ...
        'filesLoadedLocations.mat'));
end

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

%% Reference Field Shapes

% For extending fields beyond GPS point boundaries.
halfHeaderWidth = HEADER_WIDTH/2;

filePathToRefFieldShapes ...
    = fullfile(FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
    'refFieldPolyshapeLonLat.mat');

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
    '] Loading history field alpha shapes...']);
% Load history field shapes.
load(fullfile(FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY, ...
    'enhancedFieldShapesUtm.mat'));
load(fullfile(FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY, ...
    'enhancedFieldShapesUtmZones.mat'));

if ~exist(filePathToRefFieldShapes, 'file')
    disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Generating reference field polyshape...']);
    
    disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Generating field polyshapes by extending the alpha shapes...']);
    % Convert the alpha shape in UTM to polyshapes in (lon, lat);
    refFieldsPolyshapeLonLat = polyshape([nan nan]);
    numOfFields = length(enhancedFieldShapesUtm);
    for idxF = 1:numOfFields
        disp(['        [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
            '] Field ', num2str(idxF), '/', num2str(numOfFields)]);
        curZone = enhancedFieldShapesUtmZones{idxF};
        
        curFieldPolyshapeLonLat = alphaShapeUtm2PolyshapeLonLat( ...
            enhancedFieldShapesUtm{idxF}, curZone);
        % Expand the field shape by half of the header width.
        curFieldPolyshapeLonLatExt ...
            = extendPolyshapeLonLatWithHoles( ...
            curFieldPolyshapeLonLat, ...
            halfHeaderWidth);
        refFieldsPolyshapeLonLat = union(refFieldsPolyshapeLonLat, ...
            curFieldPolyshapeLonLatExt);
    end
    
    if FLAG_GENERATE_ROAD_POLYSHAPE
        % Plot for debugging.
        filePathToFigFieldsVsRoad ...
            = fullfile(FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
            'figOldFieldsVsRoad');
        
        hFigFieldsVsRoad = figure;
        hold on;
        hOldFields = plot(refFieldsPolyshapeLonLat, ...
            'FaceColor', 'green', 'FaceAlpha', 0.5);
        hRoad = plot(roadsPolyshapeLonLat, ...
            'FaceColor', 'black', 'FaceAlpha', 0.5);
        hToRemove = plot( ...
            intersect(refFieldsPolyshapeLonLat, roadsPolyshapeLonLat), ...
            'FaceColor', 'red', 'FaceAlpha', 0.5);
        axis equal;
        legend([hRoad, hOldFields, hToRemove], ...
            'Roads', 'Old Ref Fields', 'Field Parts to Remove');
        saveas(hFigFieldsVsRoad, [filePathToFigFieldsVsRoad, '.fig']);
        saveas(hFigFieldsVsRoad, [filePathToFigFieldsVsRoad, '.png']);
        
        % Refine location labels based on truck tracks.
        refFieldsPolyshapeLonLat ...
            = subtract(refFieldsPolyshapeLonLat, roadsPolyshapeLonLat);
    end
    
    % Clear the field polygons a little bit by removing regions that are
    % too small.
    oldRefFieldsPolyshapeLonLat = refFieldsPolyshapeLonLat;
    refFieldsPolyshapeLonLat ...
        = removeSmallSegsInPolyshapeLonLat( ...
        oldRefFieldsPolyshapeLonLat, MIN_FIELD_AREA);
    
    % Plot for debugging.
    filePathToFigFieldsSmallSegs ...
        = fullfile(FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
        'figFieldsSmallSegs');
    
    hFigFieldsVsRoad = figure;
    hold on;
    hFields = plot(refFieldsPolyshapeLonLat, ...
        'FaceColor', 'green', 'FaceAlpha', 0.5);
    hRemoved = plot( ...
        subtract(oldRefFieldsPolyshapeLonLat, ...
        refFieldsPolyshapeLonLat), ...
        'FaceColor', 'red', 'FaceAlpha', 0.5);
    axis equal;
    legend([hFields, hRemoved], ...
        'Ref Fields', 'Field Parts Removed');
    saveas(hFigFieldsVsRoad, [filePathToFigFieldsSmallSegs, '.fig']);
    saveas(hFigFieldsVsRoad, [filePathToFigFieldsSmallSegs, '.png']);
    
    disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Saving results...']);
    save(filePathToRefFieldShapes, 'refFieldsPolyshapeLonLat');
else
    disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Loading reference field polyshape...']);
    load(filePathToRefFieldShapes);
end

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

%% Generate Information for Each Field
% We also save a polyshape array for each field (ordered by when they start
% being harvested), together with the GPS records (ordered) and bools for
% which GPS points are in which fields.

filePathToRefFieldShapesExtraInfo ...
    = fullfile(FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
    'refFieldPolyshapeLonLatExtraInfo.mat');

if ~exist(filePathToRefFieldShapesExtraInfo, 'file')
    disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Generating extra info for reference field polyshape...']);
    fieldsPolyshpsLonLat = regions(refFieldsPolyshapeLonLat);
    numOfFields = length(fieldsPolyshpsLonLat);
    
    % Get all GPS records by vehicle type for convenience.
    boolsFileIsC = strcmp({files.type}, 'Combine');
    boolsFileIsK = strcmp({files.type}, 'Grain Kart');
    boolsFileIsT = strcmp({files.type}, 'Truck');
    allGpstimeLonLatsC = [vertcat(files(boolsFileIsC).gpsTime), ...
        vertcat(files(boolsFileIsC).lon), ...
        vertcat(files(boolsFileIsC).lat)];
    allSpeedsC = vertcat(files(boolsFileIsC).speed);
    allGpstimeLonLatsK = [vertcat(files(boolsFileIsK).gpsTime), ...
        vertcat(files(boolsFileIsK).lon), ...
        vertcat(files(boolsFileIsK).lat)];
    allGpstimeLonLatsT = [vertcat(files(boolsFileIsT).gpsTime), ...
        vertcat(files(boolsFileIsT).lon), ...
        vertcat(files(boolsFileIsT).lat)];
    
    % Order these records by GPS time.
    [allGpstimeLonLatsC, indicesAllGpsTimeLonLatsC] ...
        = sortrows(allGpstimeLonLatsC);
    allSpeedsC = allSpeedsC(indicesAllGpsTimeLonLatsC);
    allGpstimeLonLatsK = sortrows(allGpstimeLonLatsK);
    allGpstimeLonLatsT = sortrows(allGpstimeLonLatsT);
    
    % Remove anomalies (we have observed data with GPS times that are way
    % off the expected year).
    gpsTimeRangeInMs = gpsTimeRangeInS.*1000;
    boolsGpsRecToRmC = (allGpstimeLonLatsC(:,1)<gpsTimeRangeInMs(1)) ...
        |(allGpstimeLonLatsC(:,1)>gpsTimeRangeInMs(2));
    allGpstimeLonLatsC(boolsGpsRecToRmC, :) = [];
    allSpeedsC(boolsGpsRecToRmC, :) = [];
    boolsGpsRecToRmK = (allGpstimeLonLatsK(:,1)<gpsTimeRangeInMs(1)) ...
        |(allGpstimeLonLatsK(:,1)>gpsTimeRangeInMs(2));
    allGpstimeLonLatsK(boolsGpsRecToRmK, :) = [];
    boolsGpsRecToRmT = (allGpstimeLonLatsT(:,1)<gpsTimeRangeInMs(1)) ...
        |(allGpstimeLonLatsT(:,1)>gpsTimeRangeInMs(2));
    allGpstimeLonLatsT(boolsGpsRecToRmT, :) = [];
    
    % Reorder the fields based on when they start being harvested. We will
    % locate these time points by (1) when a combines shows up in the
    % field, and (2) whether the future/past GPS points are mostly active
    % (with a non-zero speed).
    disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Determining harvest start and end time for each field...']);
    
    % Check which samples keep active in the future and in the past.
    numSampsC = length(allSpeedsC);
    boolsWillBeActiveC = nan(numSampsC, 1);
    boolsWasActiveC = nan(numSampsC, 1);
    for idxSampC = 1:numSampsC
        testResults = allSpeedsC( ...
            idxSampC:min(idxSampC+MIN_NUM_OF_ACTIVE_SAMPS_C-1, ...
            numSampsC))>0;
        timeTestInS = (allGpstimeLonLatsC( ...
            min(idxSampC+MIN_NUM_OF_ACTIVE_SAMPS_C-1, numSampsC), 1) ...
            - allGpstimeLonLatsC(idxSampC, 1))/1000;
        boolsWillBeActiveC(idxSampC) = ...
            (sum(testResults)./timeTestInS)...
            >= THRESHOLD_ACTIVE_SAMPS_MAJORITY;
        
        testResults = allSpeedsC( ...
            max(idxSampC-MIN_NUM_OF_ACTIVE_SAMPS_C+1, 1):idxSampC)>0;
        timeTestInS = (allGpstimeLonLatsC(idxSampC, 1) ...
            - allGpstimeLonLatsC( ...
            max(idxSampC-MIN_NUM_OF_ACTIVE_SAMPS_C+1, 1), 1))/1000;
        boolsWasActiveC(idxSampC) = ...
            (sum(testResults)./timeTestInS)...
            >= THRESHOLD_ACTIVE_SAMPS_MAJORITY;
    end
    
    % Find start and end time for harvesting the field of interest. Note
    % that these time are for the main harvesting activites used for
    % generating harvesting progress video demos. For example, combines
    % could show up in the field before the start time and park there for a
    % long time.
    cellBoolsGpsPtInFieldC = cell(numOfFields,1);
    [gpsTimesHarvStart, gpsTimesHarvEnd] = deal(nan(numOfFields,1));
    for idxF = 1:numOfFields
        disp(['        [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
            '] Field ', num2str(idxF), '/', num2str(numOfFields)]);
        
        % Find in-field combine samples.
        curFPolyShpLonLat = fieldsPolyshpsLonLat(idxF);
        cellBoolsGpsPtInFieldC{idxF} = ...
            isInteriorFast(curFPolyShpLonLat, ...
            allGpstimeLonLatsC(:,2), allGpstimeLonLatsC(:,3));
        
        gpsTimesHarvStart(idxF) = allGpstimeLonLatsC( ...
            find(cellBoolsGpsPtInFieldC{idxF}&boolsWillBeActiveC, ...
            1, 'first'),1);
        gpsTimesHarvEnd(idxF) = allGpstimeLonLatsC( ...
            find(cellBoolsGpsPtInFieldC{idxF}&boolsWasActiveC, ...
            1, 'last'),1);
    end
    
    [gpsTimesHarvStart, indicesFields] = sort(gpsTimesHarvStart);
    fieldsPolyshpsLonLat = fieldsPolyshpsLonLat(indicesFields);
    gpsTimesHarvEnd = gpsTimesHarvEnd(indicesFields);
    cellBoolsGpsPtInFieldC = cellBoolsGpsPtInFieldC(indicesFields);
    
    % Compute the total area to harvest this season.
    disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Computing field sizes...']);
    [areaFieldsInM2, areaFieldsInAcre] = deal(nan(numOfFields,1));
    for idxF = 1:numOfFields
        curFieldPolyshpLonLat = fieldsPolyshpsLonLat(idxF);
        areaFieldsInM2(idxF) = areaPolyshapeLonLat(curFieldPolyshpLonLat);
        areaFieldsInAcre(idxF) = m22acre(areaFieldsInM2(idxF));
    end
    totalAreaFieldsInM2 = sum(areaFieldsInM2);
    totalAreaFieldsInAcre = sum(areaFieldsInAcre);
    
    disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Saving results...']);
    save(filePathToRefFieldShapesExtraInfo, 'fieldsPolyshpsLonLat', ...
        'allGpstimeLonLatsC', 'allSpeedsC', ...
        'allGpstimeLonLatsK', 'allGpstimeLonLatsT', ...
        'boolsWillBeActiveC', 'boolsWasActiveC', ...
        'cellBoolsGpsPtInFieldC', ...
        'gpsTimesHarvStart', 'gpsTimesHarvEnd', ...
        'areaFieldsInM2', 'areaFieldsInAcre', ...
        'totalAreaFieldsInM2', 'totalAreaFieldsInAcre');
else
    disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Loading extra info for reference field polyshape...']);
    load(filePathToRefFieldShapesExtraInfo);
end

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

%% Generate Harvest Progress Videos for Each Field

% For creating field shapes in UTM.
fieldAlpha = enhancedFieldShapesUtm{1}.Alpha;

% Save the harvest progress info for the OADA JSON file generation. Please
% refer to exampleHarvestProgressInfo.hjson and generateJsonForOada.m for
% more details. Note that: (1) the GPS data is already saved in files.mat;
% and (2) the reference field shape polygons are already saved
% infilePathToRefFieldShapesExtraInfo.
folderToSaveProgressInfo = fullfile( ...
    FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
    'ProgressMoniteringInfo');

if ~exist(folderToSaveProgressInfo, 'dir')
    mkdir(folderToSaveProgressInfo);
end

% We will produce video demos to visualize the results.
folderToSaveMovies = fullfile( ...
    FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
    'ProgressMoniteringVideoDemos');

if ~exist(folderToSaveMovies, 'dir')
    mkdir(folderToSaveMovies);
end

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
    '] Generating harvest progress video demos...']);

% Video parameters.
simTimeLenghtPerFrameInS = PLAYBACK_SPEED/VIDEO_FRAME_RATE;
assert(floor(simTimeLenghtPerFrameInS)==simTimeLenghtPerFrameInS, ...
    ['For simplicity, ', ...
    'please make sure PLAYBACK_SPEED/VIDEO_FRAME_RATE is an integer!']);

% Find in field combine GPS points for estimating harvested area for the
% whole season.
boolsGpsPtInAnyFieldC = false(size(allGpstimeLonLatsC, 1), 1);
totalNumOfFields = length(fieldsPolyshpsLonLat);
for idxF = 1:totalNumOfFields
    boolsGpsPtInAnyFieldC = boolsGpsPtInAnyFieldC ...
        | cellBoolsGpsPtInFieldC{idxF};
end

% One video demo for each field if there is no inactive gaps.
paddingTimeAfterHarvestInMs = PADDING_TIME_AFTER_HARVEST_IN_S *1000;
maxAllowedInactiveTimeLenthInMs = ...
    MAX_ALLOWED_INACTIVE_TIME_LENGTH_IN_S *1000;
for idxF = 1:totalNumOfFields
    curVideoClipCounter = 1;
    curVideoFileName = ['field_', num2str(idxF)];
    pathToSaveProgInfo = fullfile(folderToSaveProgressInfo, ...
        [curVideoFileName, '_', ...
        num2str(curVideoClipCounter), '.mat']);
    pathToSaveVideo = fullfile(folderToSaveMovies, ...
        [curVideoFileName, '_', ...
        num2str(curVideoClipCounter), '.mp4']);
    
    if ~exist(pathToSaveVideo, 'file')
        disp(['        [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
            '] Field ', num2str(idxF), '/', num2str(totalNumOfFields)]);
        
        % Initialize the figure with the field shape.
        curFieldPolyshpLonLat = fieldsPolyshpsLonLat(idxF);
        areaCurFieldInM2 = areaFieldsInM2(idxF);
        areaCurFieldInAcre = areaFieldsInAcre(idxF);
        
        curGpsTimeHarvStart = gpsTimesHarvStart(idxF);
        curGpsTimeHarvEnd = gpsTimesHarvEnd(idxF);
        
        % Find the time zone for this field.
        curFieldNonNanLons = curFieldPolyshpLonLat.Vertices(:, 1);
        curFieldNonNanLons( ...
            isnan(curFieldNonNanLons), :) = [];
        curFieldMeanLon = mean(curFieldNonNanLons);
        curTimeZone = [ ...
            sprintf('%+03d', -timezone(curFieldMeanLon,'degrees')), ...
            ':00'];
        
        % Find all combine samples that are in current field.
        allGpstimeLonLatsInCurFieldC = allGpstimeLonLatsC( ...
            cellBoolsGpsPtInFieldC{idxF}, :);
        allSpeedsInCurFieldC = allSpeedsC(cellBoolsGpsPtInFieldC{idxF});
        
        % For locating inactive gaps.
        boolsWillBeActiveInCurFieldC = ...
            boolsWillBeActiveC(cellBoolsGpsPtInFieldC{idxF});
        boolsWasActiveInCurFieldC = ...
            boolsWasActiveC(cellBoolsGpsPtInFieldC{idxF});
        
        % Plot the background.
        hFigHarvProg = figure('MenuBar', 'none', 'ToolBar', 'none');
        hold on;
        hCurField = plot(curFieldPolyshpLonLat, ...
            'FaceColor', faceColorField, 'EdgeColor', edgeColorField, ...
            'FaceAlpha', faceAlphaField, 'EdgeAlpha', edgeAlphaField);
        axis tight;
        plot_google_map('MapType', 'satellite');
        axis manual;
        % Plot history GPS data.
        boolsHistGpsPtToShowC = ...
            allGpstimeLonLatsC(:,1)<curGpsTimeHarvStart;
        hHistGpsC = plotHistGps( ...
            allGpstimeLonLatsC(boolsHistGpsPtToShowC, 2), ...
            allGpstimeLonLatsC(boolsHistGpsPtToShowC, 3), ...
            colorC, sizeHistGpsPt, alphaHistGpsPt);
        
        boolsHistGpsPtToShowK = ...
            allGpstimeLonLatsK(:,1)<curGpsTimeHarvStart;
        hHistGpsK = plotHistGps( ...
            allGpstimeLonLatsK(boolsHistGpsPtToShowK, 2), ...
            allGpstimeLonLatsK(boolsHistGpsPtToShowK, 3), ...
            colorK, sizeHistGpsPt, alphaHistGpsPt);
        
        boolsHistGpsPtToShowT = ...
            allGpstimeLonLatsT(:,1)<curGpsTimeHarvStart;
        hHistGpsT = plotHistGps( ...
            allGpstimeLonLatsT(boolsHistGpsPtToShowT, 2), ...
            allGpstimeLonLatsT(boolsHistGpsPtToShowT, 3), ...
            colorT, sizeHistGpsPt, alphaHistGpsPt);
        
        % Labels and titles.
        xlabel('Longitude'); ylabel('Latitude');
        title({['Field #', num2str(idxF), ' | Area: ', ...
            num2str(areaCurFieldInAcre, '%.2f'), ' Acre | ', ...
            'Local Time: ', datestr(gpsTimeInMs2DateTimeLocal( ...
            curGpsTimeHarvStart, curTimeZone))]; ...
            'Field Progress: being evaluated...'; ...
            'Overview: being evaluated...'; ...
            'Total Progress: being evaluated...'}, 'FontSize', titleFontSize);
        
        % Playback speed.
        xL=xlim; yL=ylim;
        hPlaybackSpeed = text(xL(2), yL(2), ...
            ['Playback Speed: x', num2str(PLAYBACK_SPEED)], ...
            'HorizontalAlignment', 'right', ...
            'VerticalAlignment', 'top', ...
            'Color', 'w', 'FontWeight', 'bold', ...
            'FontSize', titleFontSize);
        
        % Create a video writer for outputting the frames.
        curVideoWriter = VideoWriter( ...
            pathToSaveVideo, 'MPEG-4'); %#ok<TNMLP>
        curVideoWriter.FrameRate = VIDEO_FRAME_RATE;
        open(curVideoWriter);
        
        drawnow;
        writeVideo(curVideoWriter, getframe(hFigHarvProg));
        
        % Locate combine GPS records in this field based on the start and
        % end GPS times and generate progress polygons for the videos
        % accordingly.
        lastCurGpsTimeInMs = curGpsTimeHarvStart-1000;
        [hCurProgPoly, hTrailGpsPtsC, hTrailGpsPtsK, hTrailGpsPtsT] ...
            = deal([]);
        simGpsTimesInMs = (curGpsTimeHarvStart ...
            :(simTimeLenghtPerFrameInS*1000):curGpsTimeHarvEnd);
        numOfSimGpsTimes = length(simGpsTimesInMs);
        numOfSimGpsTimesPerReport = ceil(numOfSimGpsTimes.*0.1);
        [numOfSimGpsTimesDone, numOfSimGpsTimesDoneTemp] = deal(0);
        % Disable these warnings temporarily .
        warning('off', 'MATLAB:alphaShape');
        warning('off', 'MATLAB:polyshape:repairedBySimplify');
        warning('off', 'MATLAB:alphaShape:DupPointsBasicWarnId');
        earlyTerminationTimerStartInMs = nan;
        % We need a time flag to skip inactive gaps.
        timeToResumeVideoInMs = -inf;
        % Keep a record of the progress polygons and the harvest progress
        % information for data exportion. Note:
        %   - total number of fields is already available as
        %     totalNumOfFields;
        %   - total area in acre for all fields is already available in
        %     filePathToRefFieldShapesExtraInfo as totalAreaFieldsInAcre.
        % We will for speed, prelocate the sizes of these variables based
        % on the maximum expected size, and for convenience, save them
        % without removing the empty cells/NaN values.
        [progressPolygonsLonLat, progressTimeStrs] ...
            = deal(cell(numOfSimGpsTimes, 1));
        [progressPolygonAreasInAcre, progressPolygonHarvRatios, ...
            progressOverviewNumsOfFieldsHarvsted, ...
            progressOverviewNumsOfFieldsBeingHarvsted, ...
            progressOverviewAreasInAcreHarvested, ...
            progressOverviewHarvRatios, ...
            progressGpsTimesInS] ...
            = deal(nan(numOfSimGpsTimes, 1));
        videoStartEndGpsTimesInMs = [simGpsTimesInMs(1) nan];
        % Last available alpha shapes for speeding up progress polygon
        % generation.
        [harvProgAlphaShpInfo, beingHarvAlphaShpLonLat] = deal([]);
        for curGpsTimeInMs = simGpsTimesInMs
            % Skip frames until the preset time flag.
            if curGpsTimeInMs<timeToResumeVideoInMs
                continue;
            end
            
            if numOfSimGpsTimesDoneTemp>=numOfSimGpsTimesPerReport
                disp(['            [', ...
                    datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] ', ...
                    num2str(...
                    numOfSimGpsTimesDone./numOfSimGpsTimes.*100, ...
                    '%.2f'), '%...']);
                numOfSimGpsTimesDoneTemp = 0;
            end
            
            boolsHarvC = ...
                (allGpstimeLonLatsInCurFieldC(:,1)<=curGpsTimeInMs) ...
                & (allSpeedsInCurFieldC ~= 0);            
            [harvProgPolyshpLonLat, harvProgAlphaShpInfo] ...
                = genHarvProgPolyshapeLonLat( ...
                allGpstimeLonLatsInCurFieldC(boolsHarvC,3), ...
                allGpstimeLonLatsInCurFieldC(boolsHarvC,2), ...
                fieldAlpha, halfHeaderWidth, curFieldPolyshpLonLat, ...
                harvProgAlphaShpInfo);
            areaHarvestedInM2 = areaPolyshapeLonLat(harvProgPolyshpLonLat);
            areaHarvestedInAcre = m22acre(areaHarvestedInM2);
            
            curProg = areaHarvestedInM2./areaCurFieldInM2;
            
            % Add new GPS points as history to the background.
            boolsNewHistGpsPtToShowC = ...
                (allGpstimeLonLatsC(:,1)>lastCurGpsTimeInMs) ...
                &(allGpstimeLonLatsC(:,1)<=curGpsTimeInMs);
            hHistGpsC = plotHistGps( ...
                allGpstimeLonLatsC(boolsNewHistGpsPtToShowC, 2), ...
                allGpstimeLonLatsC(boolsNewHistGpsPtToShowC, 3), ...
                colorC, sizeHistGpsPt, alphaHistGpsPt);
            
            boolsNewHistGpsPtToShowK = ...
                (allGpstimeLonLatsK(:,1)>lastCurGpsTimeInMs) ...
                &(allGpstimeLonLatsK(:,1)<=curGpsTimeInMs);
            hHistGpsK = plotHistGps( ...
                allGpstimeLonLatsK(boolsNewHistGpsPtToShowK, 2), ...
                allGpstimeLonLatsK(boolsNewHistGpsPtToShowK, 3), ...
                colorK, sizeHistGpsPt, alphaHistGpsPt);
            
            boolsNewHistGpsPtToShowT = ...
                (allGpstimeLonLatsT(:,1)>lastCurGpsTimeInMs) ...
                &(allGpstimeLonLatsT(:,1)<=curGpsTimeInMs);
            hHistGpsT = plotHistGps( ...
                allGpstimeLonLatsT(boolsNewHistGpsPtToShowT, 2), ...
                allGpstimeLonLatsT(boolsNewHistGpsPtToShowT, 3), ...
                colorT, sizeHistGpsPt, alphaHistGpsPt);
            
            % Plot the latest harvest progress polyshape.
            deleteHandles(hCurProgPoly);
            hCurProgPoly = plot(harvProgPolyshpLonLat, ...
                'FaceColor', faceColorProgPoly, ...
                'EdgeColor', edgeColorProgPoly, ...
                'FaceAlpha', faceAlphaProgPoly, ...
                'EdgeAlpha', edgeAlphaProgPoly);
            % Plot the recent removable GPS points.
            deleteHandles(hTrailGpsPtsC);
            hTrailGpsPtsC = plotTrailingGpsPts( ...
                allGpstimeLonLatsC, curGpsTimeInMs, ...
                NUM_OF_TRAILING_GPS_PTS, TRAILING_GPS_PTS_SIZE_RANGE, ...
                colorC);
            deleteHandles(hTrailGpsPtsK);
            hTrailGpsPtsK = plotTrailingGpsPts( ...
                allGpstimeLonLatsK, curGpsTimeInMs, ...
                NUM_OF_TRAILING_GPS_PTS, TRAILING_GPS_PTS_SIZE_RANGE, ...
                colorK);
            deleteHandles(hTrailGpsPtsT);
            hTrailGpsPtsT = plotTrailingGpsPts( ...
                allGpstimeLonLatsT, curGpsTimeInMs, ...
                NUM_OF_TRAILING_GPS_PTS, TRAILING_GPS_PTS_SIZE_RANGE, ...
                colorT);
            
            % Estimate how much area have been harvested so far for this
            % season: total areas harvested this season = total area of the
            % fields that are harvested + total area that has been
            % harvested in fields that are being harvested.
            
            % Count how many fields have been/are being harvestd.
            indicesFieldHarvested = find(gpsTimesHarvEnd<curGpsTimeInMs);
            numOfFieldsHarvested = length(indicesFieldHarvested);
            areaFieldsHarvestedInAcre ...
                = sum(areaFieldsInAcre(indicesFieldHarvested));
            
            % Find combine GPS points in fields that are being harvested
            % for estimating harvested area for the whole season.
            boolsGpsPtInFieldsNotHarvestedC = boolsGpsPtInAnyFieldC;
            for idxFHarvested = indicesFieldHarvested'
                boolsGpsPtInFieldsNotHarvestedC = ...
                    boolsGpsPtInFieldsNotHarvestedC ...
                    & (~cellBoolsGpsPtInFieldC{idxFHarvested});
            end
            % Discard zero-speed points to speed up the polyshape
            % generation.
            allGpstimeLonLatsBeingHarvestedC = allGpstimeLonLatsC( ...
                (allGpstimeLonLatsC(:,1) <= curGpsTimeInMs) ...
                & boolsGpsPtInFieldsNotHarvestedC ...
                & (allSpeedsC ~= 0), :);
            
            [beingHarvPolyshpLonLat, beingHarvAlphaShpLonLat] ...
                = genHarvProgPolyshapeLonLat( ...
                allGpstimeLonLatsBeingHarvestedC(:,3), ...
                allGpstimeLonLatsBeingHarvestedC(:,2), ...
                fieldAlpha, halfHeaderWidth, refFieldsPolyshapeLonLat, ...
                beingHarvAlphaShpLonLat);
            areaFieldsBeingHarvestedInM2 = ...
                areaPolyshapeLonLat(beingHarvPolyshpLonLat);
            areaFieldsBeingHarvestedInAcre = m22acre(areaHarvestedInM2);
            
            numOfFieldsBeingHarvested = ...
                sum(arrayfun(@(f) ...
                overlaps(f, beingHarvPolyshpLonLat), ...
                fieldsPolyshpsLonLat));
            areaHarvestedFullSeasonInAcre = ...
                areaFieldsHarvestedInAcre ...
                + areaFieldsBeingHarvestedInAcre;
            areaHarvestRatio = areaHarvestedInAcre/areaCurFieldInAcre;
            areaHarvestedFullSeasonRatio = ...
                areaHarvestedFullSeasonInAcre/totalAreaFieldsInAcre;
            
            % Keep record of the last simulated time.
            lastCurGpsTimeInMs = curGpsTimeInMs;
            curTimeStr = datestr(gpsTimeInMs2DateTimeLocal( ...
                curGpsTimeInMs, curTimeZone));
            title({['Field #', num2str(idxF), ' | Area: ', ...
                num2str(areaCurFieldInAcre, '%.2f'), ' Acre | ', ...
                'Local Time: ', curTimeStr]; ...
                ...
                ['Field Progress: ', ...
                num2str(areaHarvestedInAcre, '%.2f'), ...
                ' Acre Harvested (', ...
                num2str(areaHarvestRatio.*100, ...
                '%.2f'), '%)']; ...
                ...
                ['Overview: ', num2str(totalNumOfFields), ...
                ' Fields in Total (', ...
                num2str(totalAreaFieldsInAcre, '%.2f'), ...
                ' Acre) | Harvested: ', ...
                num2str(numOfFieldsHarvested), ...
                ' | Being Harvested: ', ...
                num2str(numOfFieldsBeingHarvested)]; ...
                ...
                ['Total Progress: ', ...
                num2str(areaHarvestedFullSeasonInAcre, '%.2f'), ...
                ' Acre Harvested (', ...
                num2str(areaHarvestedFullSeasonRatio.*100, ...
                '%.2f'), '%)']}, ...
                'FontSize', titleFontSize);
            legend([hCurField, hCurProgPoly], ...
                ['Field #', num2str(idxF)], 'Harvested', ...
                'Location', 'southeast');
            transparentizeCurLegends;
            
            % Output the frame to the video.
            drawnow;
            writeVideo(curVideoWriter, getframe(hFigHarvProg));
            
            % Update the harvest progress info.
            idxNextEmptyMessage = find( ...
                isnan(progressGpsTimesInS), 1, 'first');
            progressPolygonsLonLat{idxNextEmptyMessage} ...
                = harvProgPolyshpLonLat;
            progressTimeStrs{idxNextEmptyMessage} = curTimeStr;
            progressGpsTimesInS(idxNextEmptyMessage) = curGpsTimeInMs/1000;
            progressPolygonAreasInAcre(idxNextEmptyMessage) ...
                = areaHarvestedInAcre;
            progressPolygonHarvRatios(idxNextEmptyMessage) ...
                = areaHarvestRatio;
            progressOverviewNumsOfFieldsHarvsted(idxNextEmptyMessage) ...
                = numOfFieldsHarvested;
            progressOverviewNumsOfFieldsBeingHarvsted( ...
                idxNextEmptyMessage) ...
                = numOfFieldsBeingHarvested;
            progressOverviewAreasInAcreHarvested(idxNextEmptyMessage) ...
                = areaHarvestedFullSeasonInAcre;
            progressOverviewHarvRatios(idxNextEmptyMessage) ...
                = areaHarvestedFullSeasonRatio;
            
            % Early termination because this field has been harvested.
            if areaHarvestRatio >= MIN_RATIO_HARVEST_DONE
                if isnan(earlyTerminationTimerStartInMs)
                    earlyTerminationTimerStartInMs = curGpsTimeInMs;
                end
                if curGpsTimeInMs - earlyTerminationTimerStartInMs ...
                        > paddingTimeAfterHarvestInMs
                    disp(['                [', ...
                        datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] ', ...
                        'Terminating early because the field is done...']);
                    break;
                end
            end
            
            % Check the active flags in the future to see wheather an
            % inactive gap is coming.
            curSampIdxC = find( ...
                allGpstimeLonLatsInCurFieldC(:,1)<=curGpsTimeInMs, ...
                1, 'last');
            % Note that the gap may occur with active samples when there is
            % no GPS data in the gap available, so we will also check
            % whether too much time has passed since the last in-field
            % combine location.
            if (~boolsWillBeActiveInCurFieldC(curSampIdxC)) ...
                    || (curGpsTimeInMs-allGpstimeLonLatsInCurFieldC( ...
                    curSampIdxC,1)>maxAllowedInactiveTimeLenthInMs)
                % Current sample is not active. Find the nearest sample in
                % the future that "was active".
                nextSampIdxWasActiveC = find( ...
                    boolsWasActiveInCurFieldC((curSampIdxC+1):end), ...
                    1, 'first');
                if isempty(nextSampIdxWasActiveC)
                    % All the remaining samples may be inactive.
                    if allGpstimeLonLatsInCurFieldC(end, 1) ...
                            - curGpsTimeInMs ...
                            > maxAllowedInactiveTimeLenthInMs
                        % No need to generate video clips anymore.
                        timeToResumeVideoInMs = inf;
                        disp(['                [', ...
                            datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] ', ...
                            'Terminating early because ', ...
                            'remaining samples are inactive...']);
                    end
                else
                    % Note that we have truncated the bool flages, so it is
                    % necessary to consider the omitted part here.
                    nextSampIdxWasActiveC ...
                        = nextSampIdxWasActiveC+curSampIdxC;
                    % Check the time length between now and the next "was
                    % active" sample.
                    possibleTimeToResumeVideoInMs = ...
                        allGpstimeLonLatsInCurFieldC( ...
                        nextSampIdxWasActiveC, 1);
                    if possibleTimeToResumeVideoInMs ...
                            - curGpsTimeInMs ...
                            > maxAllowedInactiveTimeLenthInMs
                        timeToResumeVideoInMs = ....
                            possibleTimeToResumeVideoInMs;
                        
                        % Also we need to move on to a new video clip.
                        disp(['                [', ...
                            datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] ', ...
                            'Creating a new clip because ', ...
                            'an inactive gap is detected...']);
                        close(curVideoWriter);
                        curVideoClipCounter = curVideoClipCounter+1;
                        
                        % Save the harvest progress info to the file.
                        videoStartEndGpsTimesInMs(2) = curGpsTimeInMs;
                        save(pathToSaveProgInfo, ...
                            'progressPolygonsLonLat', 'progressTimeStrs', ...
                            'progressPolygonAreasInAcre', ...
                            'progressPolygonHarvRatios', ...
                            'progressOverviewNumsOfFieldsHarvsted', ...
                            'progressOverviewNumsOfFieldsBeingHarvsted', ...
                            'progressOverviewAreasInAcreHarvested', ...
                            'progressOverviewHarvRatios', ...
                            'progressGpsTimesInS', ...
                            'videoStartEndGpsTimesInMs');
                        
                        % Start a new video clip because an inactive gap is
                        % detected.
                        curVideoFileName = ['field_', num2str(idxF)];
                        
                        pathToSaveProgInfo = fullfile(folderToSaveProgressInfo, ...
                            [curVideoFileName, '_', ...
                            num2str(curVideoClipCounter), '.mat']);
                        pathToSaveVideo = fullfile(folderToSaveMovies, ...
                            [curVideoFileName, '_', ...
                            num2str(curVideoClipCounter), '.mp4']);
                        
                        curVideoWriter = VideoWriter( ...
                            pathToSaveVideo, 'MPEG-4'); %#ok<TNMLP>
                        curVideoWriter.FrameRate = VIDEO_FRAME_RATE;
                        open(curVideoWriter);
                        
                        % Reset the record of the progress polygons and the
                        % harvest progress information for data exportion.
                        % Note:
                        %   - total number of fields is already available
                        %   as
                        %     totalNumOfFields;
                        %   - total area in acre for all fields is already
                        %   available in
                        %     filePathToRefFieldShapesExtraInfo as
                        %     totalAreaFieldsInAcre.
                        [progressPolygonsLonLat, progressTimeStrs] ...
                            = deal(cell(numOfSimGpsTimes, 1));
                        [progressPolygonAreasInAcre, ...
                            progressPolygonHarvRatios, ...
                            progressOverviewNumsOfFieldsHarvsted, ...
                            progressOverviewNumsOfFieldsBeingHarvsted, ...
                            progressOverviewAreasInAcreHarvested, ...
                            progressOverviewHarvRatios, ...
                            progressGpsTimesInS] ...
                            = deal(nan(numOfSimGpsTimes, 1));
                        videoStartEndGpsTimesInMs = ...
                            [possibleTimeToResumeVideoInMs nan];
                        % Last available alpha shapes for speeding up
                        % progress polygon generation.
                        [harvProgAlphaShpInfo, ...
                            beingHarvAlphaShpLonLat] = deal([]);
                    end
                end
            end
            
            numOfSimGpsTimesDone = numOfSimGpsTimesDone+1;
            numOfSimGpsTimesDoneTemp = numOfSimGpsTimesDoneTemp+1;
        end
        warning('on', 'MATLAB:alphaShape');
        warning('on', 'MATLAB:polyshape:repairedBySimplify');
        warning('on', 'MATLAB:alphaShape:DupPointsBasicWarnId');
        
        disp(['            [', ...
            datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] ', ...
            num2str(numOfSimGpsTimesDone./numOfSimGpsTimes, ...
            '%.2f'), '%...']);
        
        close(curVideoWriter);
        
        % Save the harvest progress info to the file.
        videoStartEndGpsTimesInMs(2) = curGpsTimeInMs;
        save(pathToSaveProgInfo, ...
            'progressPolygonsLonLat', 'progressTimeStrs', ...
            'progressPolygonAreasInAcre', ...
            'progressPolygonHarvRatios', ...
            'progressOverviewNumsOfFieldsHarvsted', ...
            'progressOverviewNumsOfFieldsBeingHarvsted', ...
            'progressOverviewAreasInAcreHarvested', ...
            'progressOverviewHarvRatios', ...
            'progressGpsTimesInS', ...
            'videoStartEndGpsTimesInMs');
        
        % Close all figures.
        close all;
    end
end

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);
% EOF