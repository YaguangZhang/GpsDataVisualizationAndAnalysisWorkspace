%GENJSONFOROADA
% This script generate the harvest progress JSON file needed by the OADA
% web app, based on the outputs from GENPROGRESSPOLYGONS.
%
% Yaguang Zhang, Purdue, 11/22/2020

%% Set Matlab Path.

% Clear command window. Close all plot & web map display windows.
clc; clearvars -except strYearToProcess; close all;

disp('===================');
disp('generateJsonForOada');
disp('===================');

% Changed folder to "ScriptsAndFunctions" first.
cd(fullfile(fileparts(which(mfilename)), '..'));
% Set path.
setMatlabPath;

%% User Specified Parameters

if ~exist('strYearToProcess', 'var')
    strYearToProcess = '2019';
end
fileFolder = fullfile('..', '..', '..', ...
    ['Harvest_Ballet_', strYearToProcess]);

fileFolderSet = fullfile(pwd, fileFolder);
FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS = fullfile(fileFolderSet, ...
    '_AUTOGEN_IMPORTANT', 'ProgressPolygons');

% We will skip the time between segments between demo video clips. However,
% the data there still need to be uploaded. For that, we will leave the
% amount of time in second below for the emulator to finish all uploading
% tasks.
timeBetweenSegmentsInS = 5;

% For controlling the JSON file exportation for data visualization on the
% web app side.
%   - numOfJsonLogsToGen
%     The resultant JSON file would be extremely big (tens of GB, if not
%     more, according to the 2019 dataset) if all messages are put into one
%     file. So, we will evenly split the messages to smaller JSON log
%     files.
%   - numOfCharsPerWrite
%     Also, to avoid running out of RAM if too much data are printed to a
%     file at the same time, we ill limit the maximum number of characters
%     to output for each write attempt.
%   - decimationFactorGps, decimationFactorPolyshape
%     Integers. The harvest progress information generated for a whole
%     season is too big for a web app to process. To recude the data rate
%     required, we can decimate the GPS data and polygon points to reduce
%     the amount of data to transmit.
%   - flagIgnoreExtraZeroSpeedGpsPts
%     Also, we could ignore consecutive zero-speed GPS points except the
%     first one.
numOfJsonLogsToGen = 100;
numOfCharsPerWrite = 1024;

decimationFactorGps = 10;
flagDecimateByNumOfPts = true;
if flagDecimateByNumOfPts
    % We will generate a new polygon which has boundaries of this number of
    % points (the exact number could be a little off).
    numOfPtsForDecPolyshape = 100;
else
    decimationFactorPolyshape = 5; %#ok<UNRCH>
    minNumOfPtsToDecPolyshape = 500;
end
flagIgnoreExtraZeroSpeedGpsPts = true;

% The message struct cell could be huge (tens of GB); it may be better to
% regenerate it every time.
flagSaveHarvProgInfoSructCell = false;

% Only generate the JSON logs to cover these fields. Set this to NaN to
% cover all fields.
indicesFieldsToCover = [2, 4, 5, 7, 8, 9, ...
    11, 12, 17, 18, 19, ...
    20, 21, 22, 24, 26, 27, 28, 29, ...
    30, 32, 33, 34, 35, 36];

% Limit the number of digits after the decimal number.
numOfDigitsAfterDecPtGps = 6;
numOfDigitsAfterDecPtDefault = 2;

%% History Results

% For reference field shape polygons.
filePathToRefFieldShapesExtraInfo ...
    = fullfile(FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
    'refFieldPolyshapeLonLatExtraInfo.mat');

% For reference field shape polygons.
folderToLoadProgressInfo = fullfile( ...
    FULLPATH_FILEFOLDER_FOR_PROGRESS_POLYGONS, ...
    'ProgressMoniteringInfo');

% GPS tracks.
disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Loading GPS data...']);

FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY = fullfile(fileFolderSet, ...
    '_AUTOGEN_IMPORTANT');
FULLPATH_FILES_LOADED_HISTORY = fullfile(...
    FULLPATH_FILEFOLDER_FOR_FILES_LOADED_HISTORY, ...
    'filesLoadedHistory.mat'...
    );

load(FULLPATH_FILES_LOADED_HISTORY, 'files');

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

% Reference field shapes.
disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
    '] Loading reference field shapes...']);

load(filePathToRefFieldShapesExtraInfo, ...
    'fieldsPolyshpsLonLat', 'areaFieldsInAcre', 'totalAreaFieldsInAcre');

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

% Harvest progress information.
disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
    '] Loading harvest progress information...']);

[progressPolygonIndices, progressPolygonsLonLat, progressTimeStrs, ...
    progressPolygonAreasInAcre, ...
    progressPolygonHarvRatios, ...
    progressOverviewNumsOfFieldsHarvested, ...
    progressOverviewNumsOfFieldsBeingHarvested, ...
    progressOverviewAreasInAcreHarvested, ...
    progressOverviewHarvRatios, ...
    progressGpsTimesInS, ...
    videoStartEndGpsTimesInMs, ...
    videoFieldIndices] ...
    = loadHarvProgInfo(folderToLoadProgressInfo);

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

%% Organize the Data Needed
% Note:
%   - reference field shape polygons are available as fieldsPolyshpsLonLat;
%   - total area in acre for all fields is already available as
%     totalAreaFieldsInAcre.
disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
    '] Preparing harvest progress info for exportation...']);

totalNumOfFields = length(fieldsPolyshpsLonLat);

% All GPS messages. Note that we are not using a struct array because that
% will occupy too much RAM.
filesDecimated = files;
% We only need type, id, gpsTime, lat, and lon.
filesDecimated = rmfield(filesDecimated, {'time', 'altitude', 'speed', ...
    'bearing', 'accuracy'});
if decimationFactorGps>1
    % Decimate the GPS data.
    for idxFile = 1:length(files)
        curNumOfSamps = length(files(idxFile).gpsTime);
        curIndicesToDec = 1:decimationFactorGps:curNumOfSamps;
        if flagIgnoreExtraZeroSpeedGpsPts
            % Find zero-speed GPS points that need to be removed.
            [indicesStartsZeroSpe, indicesEndsZeroSpe] ...
                = findConsecutiveSubSeq(files(idxFile).speed, 0);
            boolsZeroSpeToDec = false(1, curNumOfSamps);
            for idxCurZeroSpe = 1:length(indicesStartsZeroSpe)
                boolsZeroSpeToDec( ...
                    (indicesStartsZeroSpe(idxCurZeroSpe)+1): ...
                    indicesEndsZeroSpe(idxCurZeroSpe)) = true;
            end
            curIndicesToDec = union(curIndicesToDec, ...
                find(boolsZeroSpeToDec));
        end
        filesDecimated(idxFile).gpsTime(curIndicesToDec) = [];
        filesDecimated(idxFile).lat(curIndicesToDec) = [];
        filesDecimated(idxFile).lon(curIndicesToDec) = [];
        
        % Limit the precision of the GPS info.
        filesDecimated(idxFile).gpsTime = ...
            limitNumOfDecs(filesDecimated(idxFile).gpsTime, ...
            numOfDigitsAfterDecPtDefault-3);
        filesDecimated(idxFile).lat = ...
            limitNumOfDecs(filesDecimated(idxFile).lat, ...
            numOfDigitsAfterDecPtGps);
        filesDecimated(idxFile).lon = ...
            limitNumOfDecs(filesDecimated(idxFile).lon, ...
            numOfDigitsAfterDecPtGps);
    end
end
messagesGpsStruct.gpsTimeInS = vertcat(filesDecimated.gpsTime)./1000;
messagesGpsStruct.lat = vertcat(filesDecimated.lat);
messagesGpsStruct.lon = vertcat(filesDecimated.lon);

totalNumOfMessagesGps = length(messagesGpsStruct.gpsTimeInS);
assert(length(messagesGpsStruct.lat) == totalNumOfMessagesGps, ...
    'Unexpected number of GPS lat data points!');
assert(length(messagesGpsStruct.lon) == totalNumOfMessagesGps, ...
    'Unexpected number of GPS lon data points!');

[messagesGpsStruct.type, messagesGpsStruct.id] = deal( ...
    cell(totalNumOfMessagesGps,1));
idxLastMessageGps = 0;
for idxFile = 1:length(filesDecimated)
    curNumOfMessagesGps = length(filesDecimated(idxFile).gpsTime);
    curIdxMessageGpsStart = idxLastMessageGps+1;
    curIdxMessageGpsEnd = idxLastMessageGps + curNumOfMessagesGps;
    messagesGpsStruct.type(curIdxMessageGpsStart:curIdxMessageGpsEnd) ...
        = {filesDecimated(idxFile).type};
    messagesGpsStruct.id(curIdxMessageGpsStart:curIdxMessageGpsEnd) ...
        = {filesDecimated(idxFile).id};
    idxLastMessageGps = curIdxMessageGpsEnd;
end

% Disable these warnings temporarily .
warning('off', 'MATLAB:alphaShape');
warning('off', 'MATLAB:polyshape:repairedBySimplify');
warning('off', 'MATLAB:alphaShape:DupPointsBasicWarnId');

% All reference field shape messages.
fieldsPolyshpsLonLatDecimated = fieldsPolyshpsLonLat;

% Decimate the reference polygons.
for idxField = 1:totalNumOfFields
    if flagDecimateByNumOfPts
        fieldsPolyshpsLonLatDecimated(idxField) ...
            = decimatePolyshapeByNumOfPts( ...
            fieldsPolyshpsLonLatDecimated(idxField), ...
            numOfPtsForDecPolyshape);
    elseif decimationFactorPolyshape>1 %#ok<UNRCH>
        fieldsPolyshpsLonLatDecimated(idxField) ...
            = decimatePolyshape( ...
            fieldsPolyshpsLonLatDecimated(idxField), ...
            decimationFactorPolyshape, ...
            minNumOfPtsToDecPolyshape);
    end
    
    % Limit the precision of the GPS info.
    fieldsPolyshpsLonLatDecimated(idxField).Vertices = ...
        limitNumOfDecs( ...
        fieldsPolyshpsLonLatDecimated(idxField).Vertices, ...
        numOfDigitsAfterDecPtGps);
end

messagesFieldShapeStruct.polyshapeLonLat = fieldsPolyshpsLonLatDecimated;
% Limit the precision of the area info.
messagesFieldShapeStruct.areaInAcre = limitNumOfDecs(areaFieldsInAcre, ...
    numOfDigitsAfterDecPtDefault);

totalNumOfMessagesFieldShape = length( ...
    messagesFieldShapeStruct.polyshapeLonLat);
assert(length(messagesFieldShapeStruct.areaInAcre) ...
    == totalNumOfMessagesFieldShape, ...
    'Unexpected number of field size values!');

% All messages for harvest progress polygons.
decimatedProgPolygonsLonLat = progressPolygonsLonLat;

% Decimate the reference polygons.
for idxProgPoly = 1:length(decimatedProgPolygonsLonLat)
    if flagDecimateByNumOfPts
        decimatedProgPolygonsLonLat(idxProgPoly) ...
            = decimatePolyshapeByNumOfPts( ...
            decimatedProgPolygonsLonLat(idxProgPoly), ...
            numOfPtsForDecPolyshape);
    elseif decimationFactorPolyshape>1 %#ok<UNRCH>
        decimatedProgPolygonsLonLat(idxProgPoly) ...
            = decimatePolyshape( ...
            decimatedProgPolygonsLonLat(idxProgPoly), ...
            decimationFactorPolyshape, ...
            minNumOfPtsToDecPolyshape);
    end
    
    % Limit the precision of the GPS info.
    decimatedProgPolygonsLonLat(idxField).Vertices = ...
        limitNumOfDecs( ...
        decimatedProgPolygonsLonLat(idxField).Vertices, ...
        numOfDigitsAfterDecPtGps);
end

progressGpsTimesInSLimPre = limitNumOfDecs(progressGpsTimesInS, ...
    numOfDigitsAfterDecPtDefault-3);

messagesProgPolyStruct.gpsTimeInS = progressGpsTimesInSLimPre;
messagesProgPolyStruct.timeStr = progressTimeStrs;
messagesProgPolyStruct.index = progressPolygonIndices;
messagesProgPolyStruct.polyshapeLonLat = decimatedProgPolygonsLonLat;
messagesProgPolyStruct.areaInAcre = ...
    limitNumOfDecs(progressPolygonAreasInAcre, ...
    numOfDigitsAfterDecPtDefault);
% Note these values will be shown as percentage numbers.
messagesProgPolyStruct.progress = ...
    limitNumOfDecs(progressPolygonHarvRatios, ...
    numOfDigitsAfterDecPtDefault+2);

totalNumOfMessagesProgPoly = length( ...
    messagesProgPolyStruct.gpsTimeInS);

% Re-enable these warnings temporarily .
warning('on', 'MATLAB:alphaShape');
warning('on', 'MATLAB:polyshape:repairedBySimplify');
warning('on', 'MATLAB:alphaShape:DupPointsBasicWarnId');

% All messages for the overall progress information of the whole harvest
% season.
messagesOverallProgStruct.gpsTimeInS = progressGpsTimesInSLimPre;
messagesOverallProgStruct.timeStr = progressTimeStrs;
messagesOverallProgStruct.index = progressPolygonIndices;
messagesOverallProgStruct.totalNumOfFields ...
    = ones(size(progressGpsTimesInSLimPre)).*totalNumOfFields;
messagesOverallProgStruct.numOfFieldsHarvested ...
    = progressOverviewNumsOfFieldsHarvested;
messagesOverallProgStruct.numOfFieldsBeingHarvested ...
    = progressOverviewNumsOfFieldsBeingHarvested;
messagesOverallProgStruct.totalHarvestedAreaInAcre ...
    = limitNumOfDecs(progressOverviewAreasInAcreHarvested, ...
    numOfDigitsAfterDecPtDefault+2);
messagesOverallProgStruct.totalAreaInAcre ...
    = ones(size(progressGpsTimesInSLimPre)) ...
    .*limitNumOfDecs(totalAreaFieldsInAcre, ...
    numOfDigitsAfterDecPtDefault+2);
% Note these values will be shown as percentage numbers.
messagesOverallProgStruct.progress = ...
    limitNumOfDecs(progressOverviewHarvRatios, ...
    numOfDigitsAfterDecPtDefault+2);

totalNumOfMessagesOverallProg = length( ...
    messagesOverallProgStruct.gpsTimeInS);
assert(totalNumOfMessagesProgPoly ...
    == totalNumOfMessagesOverallProg, ...
    'Unexpected number of overall progress messages!');

% Order all the messages by gpsTime. In order to keep the ability of find
% the message, we also have message type index (1: GPS; 2: harvest progress
% polygon; 3: overall progress) and the message's index in its type. Note
% that reference field shape messages do not have the gpsTime info.
msgIndicesWithAllGpsTimeInS = ...
    [ones(totalNumOfMessagesGps, 1), (1:totalNumOfMessagesGps)', ...
    messagesGpsStruct.gpsTimeInS; ...
    ...
    ones(totalNumOfMessagesProgPoly, 1).*2, ...
    (1:totalNumOfMessagesProgPoly)', messagesProgPolyStruct.gpsTimeInS; ...
    ...
    ones(totalNumOfMessagesOverallProg, 1).*3, ...
    (1:totalNumOfMessagesOverallProg)', ...
    messagesOverallProgStruct.gpsTimeInS];

msgIndicesWithAllGpsTimeInS = sortrows(msgIndicesWithAllGpsTimeInS,3);

disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

%% Save Results in a Cell
disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
    '] Saving messages in a cell...']);

pathToSaveMat = fullfile( ...
    folderToLoadProgressInfo, 'harvestProgressInfo.mat');

if (flagSaveHarvProgInfoSructCell && exist(pathToSaveMat, 'file'))
    disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] History results found! Loading harvProgInfoSructCell...']);
    load(pathToSaveMat);
else
    % Total number of messages.
    totalNumOfMessages = totalNumOfMessagesGps ...
        + totalNumOfMessagesFieldShape + totalNumOfMessagesProgPoly ...
        + totalNumOfMessagesOverallProg;
    
    % Create a struct of the JSON file.
    harvProgInfoSructCell = cell(totalNumOfMessages, 1);
    
    % Fill in the reference field shapes with timeInS=0 for the OADA data
    % stream emulator.
    curIdxMsg = 1;
    if isnan(indicesFieldsToCover)
        indicesFieldsToCover = 1:totalNumOfFields;
    end
    for idxMsgFieldShape = indicesFieldsToCover
        harvProgInfoSructCell{curIdxMsg} = struct(...
            'timeInS', 0, ...
            'message', 'FieldShape', ...
            'index', idxMsgFieldShape, ...
            'areaInAcre', ...
            messagesFieldShapeStruct.areaInAcre(idxMsgFieldShape));
        harvProgInfoSructCell{curIdxMsg}.polygon ...
            = polyshapeLonLat2jsonCell( ...
            messagesFieldShapeStruct.polyshapeLonLat(idxMsgFieldShape));
        curIdxMsg = curIdxMsg+1;
    end
    
    % Convert the video start and end times to second.
    videoStartEndGpsTimesInS = videoStartEndGpsTimesInMs./1000;
    
    % Generate other messages based on the demo video time info.
    numOfVideoClips = size(videoStartEndGpsTimesInS,1);
    lastProcessedTimeInS = 0;
    curSimTimeInS = 1;
    for idxVideoClip = 1:numOfVideoClips
        disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
            '] Video clip ', num2str(idxVideoClip), ...
            '/', num2str(numOfVideoClips), '...']);
        
        curStartGpsTimeInS = videoStartEndGpsTimesInS(idxVideoClip,1);
        curEndGpsTimeInS = videoStartEndGpsTimesInS(idxVideoClip,2);
        
        if any(indicesFieldsToCover==videoFieldIndices(idxVideoClip))
            % All the messages between lastProcessedTimeInS and
            % curStartGpsTimeInS need to be processed first.
            curSimTimeInS = curSimTimeInS + 1;
            preMsgIndicesWithAllGpsTimeInS = msgIndicesWithAllGpsTimeInS( ...
                (msgIndicesWithAllGpsTimeInS(:,3)>lastProcessedTimeInS) ...
                &(msgIndicesWithAllGpsTimeInS(:,3)<curStartGpsTimeInS), :);
            curNumMsgsToProc = size(preMsgIndicesWithAllGpsTimeInS, 1);
            for idxMsg = 1:curNumMsgsToProc
                curMsgIdxWithAllGpsTimeInS = ...
                    preMsgIndicesWithAllGpsTimeInS(idxMsg, :);
                curIdxMsgType = curMsgIdxWithAllGpsTimeInS(1);
                curIdxMsgInStruct = curMsgIdxWithAllGpsTimeInS(2);
                % Process the message based on its type (1: GPS; 2: harvest
                % progress polygon; 3: overall progress).
                switch curIdxMsgType
                    case 1
                        % GPS.
                        curMsgStruct = struct( ...
                            'timeInS', curSimTimeInS, ...
                            'message', 'GPS', ...
                            'gpsTimeInS', ...
                            messagesGpsStruct.gpsTimeInS(curIdxMsgInStruct), ...
                            'type', messagesGpsStruct.type{curIdxMsgInStruct}, ...
                            'id', messagesGpsStruct.id{curIdxMsgInStruct}, ...
                            'location', struct( ...
                            'lat', messagesGpsStruct.lat(curIdxMsgInStruct), ...
                            'lon', messagesGpsStruct.lon(curIdxMsgInStruct)));
                    case 2
                        % Harvest progress polygon.
                        curMsgStruct = struct( ...
                            'timeInS', curSimTimeInS, ...
                            'message', 'ProgressPolygon', ...
                            'gpsTimeInS', ...
                            messagesProgPolyStruct.gpsTimeInS( ...
                            curIdxMsgInStruct), ...
                            'timeStr', ...
                            messagesProgPolyStruct.timeStr{curIdxMsgInStruct}, ...
                            'index', ...
                            messagesProgPolyStruct.index(curIdxMsgInStruct), ...
                            'areaInAcre', ...
                            messagesProgPolyStruct.areaInAcre(...
                            curIdxMsgInStruct), ...
                            'progress', ...
                            messagesProgPolyStruct.progress(...
                            curIdxMsgInStruct));
                        % Note: a cell input for struct will create a
                        % struct array; so here we assign the cell element
                        % separately.
                        curMsgStruct.polygon = polyshapeLonLat2jsonCell( ...
                            messagesProgPolyStruct.polyshapeLonLat(...
                            curIdxMsgInStruct));
                    case 3
                        % Overall progress information.
                        curMsgStruct = struct( ...
                            'timeInS', curSimTimeInS, ...
                            'message', 'OverallProgress', ...
                            'gpsTimeInS', ...
                            messagesOverallProgStruct.gpsTimeInS( ...
                            curIdxMsgInStruct), ...
                            'timeStr', ...
                            messagesOverallProgStruct.timeStr{ ...
                            curIdxMsgInStruct}, ...
                            'totalNumOfFields', totalNumOfFields, ...
                            'numOfFieldsHarvested', ...
                            messagesOverallProgStruct.numOfFieldsHarvested( ...
                            curIdxMsgInStruct), ...
                            'numOfFieldsBeingHarvested', ...
                            messagesOverallProgStruct.numOfFieldsBeingHarvested(...
                            curIdxMsgInStruct), ...
                            'totalHarvestedAreaInAcre', ...
                            messagesOverallProgStruct.totalHarvestedAreaInAcre(...
                            curIdxMsgInStruct), ...
                            'totalAreaInAcre', ...
                            messagesOverallProgStruct.totalAreaInAcre(...
                            curIdxMsgInStruct), ...
                            'progress', ...
                            messagesOverallProgStruct.progress(...
                            curIdxMsgInStruct));
                    otherwise
                        error('Unkown message type!');
                end
                harvProgInfoSructCell{curIdxMsg} = curMsgStruct;
                curIdxMsg = curIdxMsg+1;
            end
            
            % All the messages between curStartGpsTimeInS and
            % curEndGpsTimeInS.
            curSimTimeInSBase = curSimTimeInS+timeBetweenSegmentsInS;
            curMsgIndicesWithAllGpsTimeInS = msgIndicesWithAllGpsTimeInS( ...
                (msgIndicesWithAllGpsTimeInS(:,3)>=curStartGpsTimeInS) ...
                &(msgIndicesWithAllGpsTimeInS(:,3)<=curEndGpsTimeInS), :);
            curNumMsgsToProc = size(curMsgIndicesWithAllGpsTimeInS, 1);
            for idxMsg = 1:curNumMsgsToProc
                curMsgIdxWithAllGpsTimeInS = ...
                    curMsgIndicesWithAllGpsTimeInS(idxMsg, :);
                curIdxMsgType = curMsgIdxWithAllGpsTimeInS(1);
                curIdxMsgInStruct = curMsgIdxWithAllGpsTimeInS(2);
                % Process the message based on its type (1: GPS; 2: harvest
                % progress polygon; 3: overall progress).
                switch curIdxMsgType
                    case 1
                        % GPS.
                        curSimTimeInS = curSimTimeInSBase ...
                            + messagesGpsStruct.gpsTimeInS(curIdxMsgInStruct) ...
                            - curStartGpsTimeInS;
                        curMsgStruct = struct( ...
                            'timeInS', curSimTimeInS, ...
                            'message', 'GPS', ...
                            'gpsTimeInS', ...
                            messagesGpsStruct.gpsTimeInS(curIdxMsgInStruct), ...
                            'type', messagesGpsStruct.type{curIdxMsgInStruct}, ...
                            'id', messagesGpsStruct.id{curIdxMsgInStruct}, ...
                            'location', struct( ...
                            'lat', messagesGpsStruct.lat(curIdxMsgInStruct), ...
                            'lon', messagesGpsStruct.lon(curIdxMsgInStruct)));
                    case 2
                        % Harvest progress polygon.
                        curSimTimeInS = curSimTimeInSBase ...
                            + messagesProgPolyStruct.gpsTimeInS( ...
                            curIdxMsgInStruct) ...
                            - curStartGpsTimeInS;
                        curMsgStruct = struct( ...
                            'timeInS', curSimTimeInS, ...
                            'message', 'ProgressPolygon', ...
                            'gpsTimeInS', ...
                            messagesProgPolyStruct.gpsTimeInS( ...
                            curIdxMsgInStruct), ...
                            'timeStr', ...
                            messagesProgPolyStruct.timeStr{curIdxMsgInStruct}, ...
                            'index', ...
                            messagesProgPolyStruct.index(curIdxMsgInStruct), ...
                            'polygon', polyshapeLonLat2jsonCell( ...
                            messagesProgPolyStruct.polyshapeLonLat(...
                            curIdxMsgInStruct)), ...
                            'areaInAcre', ...
                            messagesProgPolyStruct.areaInAcre(...
                            curIdxMsgInStruct), ...
                            'progress', ...
                            messagesProgPolyStruct.progress(...
                            curIdxMsgInStruct));
                    case 3
                        % Overall progress information.
                        curSimTimeInS = curSimTimeInSBase ...
                            + messagesOverallProgStruct.gpsTimeInS( ...
                            curIdxMsgInStruct) ...
                            - curStartGpsTimeInS;
                        curMsgStruct = struct( ...
                            'timeInS', curSimTimeInS, ...
                            'message', 'OverallProgress', ...
                            'gpsTimeInS', ...
                            messagesOverallProgStruct.gpsTimeInS( ...
                            curIdxMsgInStruct), ...
                            'timeStr', ...
                            messagesOverallProgStruct.timeStr{ ...
                            curIdxMsgInStruct}, ...
                            'totalNumOfFields', totalNumOfFields, ...
                            'numOfFieldsHarvested', ...
                            messagesOverallProgStruct.numOfFieldsHarvested( ...
                            curIdxMsgInStruct), ...
                            'numOfFieldsBeingHarvested', ...
                            messagesOverallProgStruct.numOfFieldsBeingHarvested(...
                            curIdxMsgInStruct), ...
                            'totalHarvestedAreaInAcre', ...
                            messagesOverallProgStruct.totalHarvestedAreaInAcre(...
                            curIdxMsgInStruct), ...
                            'totalAreaInAcre', ...
                            messagesOverallProgStruct.totalAreaInAcre(...
                            curIdxMsgInStruct), ...
                            'progress', ...
                            messagesOverallProgStruct.progress(...
                            curIdxMsgInStruct));
                    otherwise
                        error('Unkown message type!');
                end
                harvProgInfoSructCell{curIdxMsg} = curMsgStruct;
                curIdxMsg = curIdxMsg+1;
            end
        else
            disp(['        [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
                '] Skipped!']);
        end
        lastProcessedTimeInS = curEndGpsTimeInS;
    end
    
    % The remaining messages are of little value for visualization so we
    % will ignore them.
    harvProgInfoSructCell(cellfun(@isempty, harvProgInfoSructCell)) = [];
    
    % Save the results in a .mat file, just in case.
    disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Clearing variables to save RAM...']);
    % Clear variables to save RAM.
    clearvars -except ...
        pathToSaveMat harvProgInfoSructCell folderToLoadProgressInfo ...
        numOfJsonLogsToGen numOfCharsPerWrite ...
        flagSaveHarvProgInfoSructCell;
    if flagSaveHarvProgInfoSructCell
        % Save the results in a .mat file, just in case.
        disp(['    [', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
            '] Saving harvProgInfoSructCell ', ...
            'to a .mat file...']); %#ok<UNRCH>
        save(pathToSaveMat, 'harvProgInfoSructCell', '-v7.3');
    end
end
disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);

%% Export Results in a JSON File

if numOfJsonLogsToGen==1
    % This probably will not work for a whole season because of the size of
    % the data is too big; Matlab may run out of RAM.
    pathToSaveJson = fullfile( ...
        folderToLoadProgressInfo, 'harvestProgressInfo.json');
    disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Exporting messages in a JSON file...']);
    
    harvProgInfoJsonStr = jsonencode(harvProgInfoSructCell);
    numOfCharsToWrite = length(harvProgInfoJsonStr);
    curIdxCharWritten = 0;
    
    % We need to write the string out chunk by chunk since it is too big.
    fIdJson = fopen(pathToSaveJson, 'wt');
    while curIdxCharWritten<numOfCharsToWrite
        curIdxCharToWriteStart = curIdxCharWritten+1;
        curIdxCharToWriteEnd = min( ...
            curIdxCharWritten+numOfCharsPerWrite, numOfCharsToWrite);
        fprintf(fIdJson, harvProgInfoJsonStr( ...
            curIdxCharToWriteStart:curIdxCharToWriteEnd));
        curIdxCharWritten = curIdxCharToWriteEnd;
    end
    fclose(fIdJson);
else
    disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), ...
        '] Exporting messages in ', num2str(numOfJsonLogsToGen), ...
        ' JSON files...']);
    
    totalNumOfMessages = length(harvProgInfoSructCell);
    numOfMsgsPerJsonLog = ceil(totalNumOfMessages/numOfJsonLogsToGen);
    msgIndicesStart = (1:numOfMsgsPerJsonLog:totalNumOfMessages)';
    msgIndicesEnd = msgIndicesStart + numOfMsgsPerJsonLog - 1;
    msgIndicesEnd(end) = min(msgIndicesEnd(end), totalNumOfMessages);
    
    for idxJsonLog = 1:numOfJsonLogsToGen
        pathToSaveJson = fullfile( ...
            folderToLoadProgressInfo, ...
            ['harvestProgressInfo_seg_', num2str(idxJsonLog), '.json']);
        
        harvProgInfoJsonStr = jsonencode(harvProgInfoSructCell( ...
            msgIndicesStart(idxJsonLog):msgIndicesEnd(idxJsonLog)));
        numOfCharsToWrite = length(harvProgInfoJsonStr);
        curIdxCharWritten = 0;
        
        % We need to write the string out chunk by chunk since it is too
        % big.
        fIdJson = fopen(pathToSaveJson, 'wt');
        while curIdxCharWritten<numOfCharsToWrite
            curIdxCharToWriteStart = curIdxCharWritten+1;
            curIdxCharToWriteEnd = min( ...
                curIdxCharWritten+numOfCharsPerWrite, numOfCharsToWrite);
            fprintf(fIdJson, harvProgInfoJsonStr( ...
                curIdxCharToWriteStart:curIdxCharToWriteEnd));
            curIdxCharWritten = curIdxCharToWriteEnd;
        end
        fclose(fIdJson);
    end
end
disp(['[', datestr(now, 'yyyy/mm/dd HH:MM:ss'), '] Done!']);
% EOF